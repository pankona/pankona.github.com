<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ArchLinux | make clean; make]]></title>
  <link href="http://pankona.github.io/blog/categories/archlinux/atom.xml" rel="self"/>
  <link href="http://pankona.github.io/"/>
  <updated>2015-01-28T21:50:27+09:00</updated>
  <id>http://pankona.github.io/</id>
  <author>
    <name><![CDATA[pankona]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[二本指スワイプに戻る／進むを割り当てる方法 for Firefox on Arch Linux]]></title>
    <link href="http://pankona.github.io/blog/2014/09/15/histryback-by-swipe-on-firefox/"/>
    <updated>2014-09-15T00:30:08+09:00</updated>
    <id>http://pankona.github.io/blog/2014/09/15/histryback-by-swipe-on-firefox</id>
    <content type="html"><![CDATA[<p>ブラウザはFirefoxを好んで使っている。<br>
VimperatorとかPentadactylがあるおかげである。</p>

<p>いままで放置していた問題があって、それは二本指スワイプの挙動設定。</p>

<p>二本指で左右にスワイプしたときに、ヒストリーバック・ヒストリーフォワード、<br>
いわゆる「戻る」「進む」をやってほしいんだけど、これの設定がいまいちわからず、放置していた。<br>
ようやく設定方法がわかったので記しておく。そっこー忘れそうであるので。</p>

<p>ちなみに、「on Arch Linux」と題しているが、おそらくArchに限らないLinux全般の話ではないかと想像。<br>
UbuntuとArch Linux、どちらのFirefoxでもデフォルト設定では横方向二本指スワイプが仕事をしてくれなかったので。</p>

<p>では、以下設定手順。</p>

<h2 id="synclientの確認と設定">synclientの確認と設定</h2>

<p>そもそもタッチパッドのドライバーレベルで横方向スクロールが無効になっている可能性がある。というかなってた。<br>
なので、確認方法と設定変更方法。</p>

<h4 id="synclientコマンドを打って水平方向二本指スクロールの設定を確認する">synclientコマンドを打って水平方向二本指スクロールの設定を確認する</h4>

<p>以下のコマンドで現在の設定を確認できる。</p>

<p><code>$ synclient</code></p>

<p>ずらずらっと出てくる内容のうち、<code>HorizTwoFingerScroll</code> が確認対象の項目。<br>
値が「0」だったら無効になっている。有効にしない限り、いくら頑張って横スワイプしても効かない。</p>

<h4 id="synclientコマンドで水平方向二本指スクロールを有効にする">synclientコマンドで水平方向二本指スクロールを有効にする</h4>

<p>上の確認で有効だったらここは飛ばしてOK。無効だった場合、有効にするのは以下のコマンド。</p>

<p><code>$ synclient HorizTwoFingerScroll 1</code></p>

<p>synclientのほうはこれでOK。</p>

<h2 id="firefoxの設定">Firefoxの設定</h2>

<p>さらにFirefoxの設定を変えてやる必要がある。<br>
設定内容は<a href="https://wiki.archlinux.org/index.php/Touchpad_Synaptics">Touchpad Synaptics - Arch Linux Wiki</a>、Firefox 17.0 and laterの項を参考にした。</p>

<p>about:configを開く。設定内容は以下。</p>

<h4 id="マウスホイールのアクションを変更する">マウスホイールのアクションを変更する</h4>

<p><code>mousewheel.default.action.override_x = 2</code> とした。<br>
あんまりよく調べていないが、「2」が戻るアクションに対応している数字らしい。</p>

<h4 id="スワイプ方向を逆にする">スワイプ方向を逆にする</h4>

<p>デフォルトでは、左スワイプが「進む」、右スワイプが「戻る」になっている。<br>
逆な気がする。設定してこれを逆転させる。</p>

<p><code>mousewheel.default.delta_multiplier_x = -100</code> とした。</p>

<h4 id="感度を落とす">感度を落とす</h4>

<p>デフォルトではものすごく感度がよい。<br>
良すぎてしまって縦スワイプがちょっと横にぶれただけで戻ったり進んだりする。<br>
やりにくいので感度を落とす。</p>

<p><code>mousewheel.default.delta_multiplier_x = -10</code> とした。</p>

<h2 id="ここまでやって">ここまでやって</h2>

<p>とりあえず望む形（二本指で左スワイプで戻る、右スワイプで進む）に設定できた。結構ハードルあった。。<br>
ちなみにこれ、Mac OS向けFirefoxならデフォルトの挙動な模様。何の差なのか。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日本語入力のための設定メモ for Arch Linux]]></title>
    <link href="http://pankona.github.io/blog/2014/05/28/use-uim-mozc/"/>
    <updated>2014-05-28T07:49:23+09:00</updated>
    <id>http://pankona.github.io/blog/2014/05/28/use-uim-mozc</id>
    <content type="html"><![CDATA[<p>IMはずっとibusを使ってきたのだが、なかなか設定に融通が効かないというか、なんというか。<br>
具体的な要望としては、</p>

<ul>
<li>mozcを使いたい</li>
<li>Alt + Space でIMEを切り替えたい（Direct Inputと日本語入力をトグルする）</li>
</ul>

<p>という二点なのだが、後者の「Alt + Space」というキーバインドを設定する方法がわからず。。。<br>
きっとやり方があるというか、いままでごまかしごまかしやってきたのだが、<br>
ついに気持ち悪さが先に立って、「やめてやるわ！」となったところ。</p>

<p>で、IMとしてUIMを使ってみた。uim-mozc。<br>
そしたらいともたやすく Alt + Space でのトグルが設定できちゃったもんだから拍子抜けというか。<br>
はじめからこれ使ってれば良かったね！しばらくこれでいきます。uim-mozc。</p>

<p>備忘録的に、設定方法のメモ。<br>
Arch Linux向けです。</p>

<h2 id="基本的にはwiki参照">基本的にはWiki参照</h2>

<p>ブログに書いた内容というのはいずれ時代遅れになるので、、、<br>
やはり、Arch Wikiの<a href="https://wiki.archlinux.org/index.php/Input_Japanese_using_uim_(%E6%97%A5%E6%9C%AC%E8%AA%9E)">uim-mozcの設定方法</a>を参照するのが確実。<br>
うちもこれでいけた。</p>

<h2 id="インストールしたパッケージ">インストールしたパッケージ</h2>

<ul>
<li>uim</li>
<li>uim-mozc</li>
</ul>

<h2 id="設定箇所">設定箇所</h2>

<ul>
<li>.xinitrc の記載</li>
</ul>

<p>.xinitrcに以下を追記。uimを使う設定ですな。</p>

<p>```bash .xinitrc</p>

<h1 id="uim">uim</h1>

<p>export GTK_IM_MODULE=&#39;uim&#39;<br>
export QT_IM_MODULE=&#39;uim&#39;<br>
uim-xim &amp;<br>
export XMODIFIERS=&#39;@im=uim&#39;<br>
```</p>

<h2 id="uimの設定">uimの設定</h2>

<p><code>uim-pref-gtk</code>で設定画面を出し、色々設定する。</p>

<ul>
<li>「Global settings」の設定。</li>
</ul>

<p>-- Specify Default IMにチェックを入れる。<br>
  -- Default input method を Mozc にする。</p>

<ul>
<li>「Mozc」の設定。</li>
</ul>

<p>-- Default Input modeはDirect Inputに。<br>
  -- ついでにVIM協調モードも有効にしておく。</p>

<ul>
<li>「Mozc key bindings」の設定。</li>
</ul>

<p>-- [Mozc] on/off、両方に&quot;&lt;Alt&gt;space&quot;を設定。</p>

<h3 id="ここまでで">ここまでで</h3>

<p>Alt + Space でDirect Inputと日本語入力がトグルできるようになった。<br>
チャンスがあれば、他のIMも試してみよっかな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vaio Pro 13における手のひら検知 on Arch Linux]]></title>
    <link href="http://pankona.github.io/blog/2014/05/15/vaio-pro-palm-detect-on-archlinux/"/>
    <updated>2014-05-15T12:25:25+09:00</updated>
    <id>http://pankona.github.io/blog/2014/05/15/vaio-pro-palm-detect-on-archlinux</id>
    <content type="html"><![CDATA[<p>Vaio Pro 13にArch Linuxを入れて遊んでいる近頃である。<br>
概ね快適なLinuxライフを過ごせているのだが、一個だけ非常に不満な点がある。<br>
それは「タッチパッドの手のひら検知」。パームディテクト、Palm Detection、等と呼ばれる機能。</p>

<h3 id="手のひら検知？">手のひら検知？</h3>

<p>もはや手のひら検知について触れる必要もなさそうだが、一応。</p>

<p>Vaio Pro 13のタッチパッドはなかなか大きい。<br>
これは最近のノートPC、MBPとか他のUltraBookにも採用されていて流行と言ったら流行。<br>
これ自体は割と私は好みで、二本指、三本指でのスワイプなんかもやりやすくてなかなかいい。</p>

<p>ただ大きいタッチパッドには弊害もあって、キーボードを打ってるときに親指の付け根のあたりで触れちゃうってこと。<br>
触れちゃうとどうなるかっていうと、クリックした扱いになってしまって、つまりカーソルが飛ぶ。<br>
編集中に予期せぬ場所にカーソルが飛んでしまって、あれ、これどうなった、みたいなことになる。</p>

<p>それを解決してくれるのが、手のひら検知の仕組み。<br>
つまり意図したタッチでないと思われるものは無視してくれるというやつで、考えた人凄いと思います。</p>

<h3 id="arch-linux-on-vaio-pro-13の場合">Arch Linux on Vaio Pro 13の場合</h3>

<p>件の手のひら検知を有効にする仕組みがある（デフォルトではオフ）。<br>
synclient、PalmDetect、あたりでぐぐると結構出てくる。具体的には、<br>
<code>synclient PalamDetect=1</code> とかってやって手のひら検知を有効にする。する、のだが。</p>

<p>なんか全然効いてない気がするんですけど・・・。ということで調べてみた。<br>
ほんとに効いてるのかどうかを。</p>

<h3 id="結論からいうと効いてなかった">結論からいうと効いてなかった</h3>

<p>効いてなかったです。ちくしょうめ。やっぱりか。</p>

<p>ドライバのソースコードに簡単にログを仕込んで確認してみたところ、やっぱり効いてなかった。<br>
Arch Linuxでタッチパッドのドライバーは、Synapticsが使われている（というか大体どこでもSynapticsか）。<br>
ソースコードはこれ。Githubに公開されている。<a href="git:anongit.freedesktop.org/xorg/driverxf86-input-synaptics">xf86-input-synaptics</a></p>

<p>なんで効かないかと言うと、の前に、ソースコードからどうやって手のひら検知をしているかを調べてみたのでそれをメモ。</p>

<h3 id="どうやって手のひら検知している？">どうやって手のひら検知している？</h3>

<p>以下の3要素を考慮して手のひら検知としている模様。</p>

<ul>
<li>PalmDetectの設定が有効になっているか（synclient PalmDetect=1 で有効になるやつ）</li>
<li>PalmMinZがしきい値を超えているか（これも synclient PalmMinZ=XXX で設定できる）</li>
<li>PalmMinWidthがしきい値を超えているか（これも synclient PalmMinWidth=XXX で設定できる）</li>
</ul>

<p>PalmMinZ は、どれくらい深く（強く？）タッチパッドが押されたら手のひらと判断するか、のしきい値。<br>
PalmMinWidth は、タッチの広さを見ていて、太すぎる指は手のひらとみなしましょう、という判断のためのしきい値。</p>

<h3 id="arch-linux-on-vaio-pro-13-が手のひら検知をしてくれない理由">Arch Linux on Vaio Pro 13 が手のひら検知をしてくれない理由</h3>

<p>上記のしきい値のうち、どうやらPalmMinWidthのほうがおかしいっぽくて、<br>
どんな触り方をしても常に「0」で判定されてしまっている模様。<br>
ちなみに、SynapticsはPalmMinWidthが0のときは手のひらとして判断しないように実装されている。<br>
なので、PalmDetect、PalmMinZ、PalmMinWidth、どれをどの値にしても手のひら検知は効かないということである。ちくしょうめ。</p>

<h3 id="どうすれば解決するのか？">どうすれば解決するのか？</h3>

<h4 id="palmminwidthを正しく判定させる方法">PalmMinWidthを正しく判定させる方法</h4>

<p>調査をしているが今のところわからない。。一般ピープルに手が及ぶ範囲なのかどうか。</p>

<h4 id="それ以外の対処法？">それ以外の対処法？</h4>

<p>PalmMinWidthはもう一切判断に含めないようにソースコードを書き換えてみたが、、、<br>
それってつまりタッチ深度だけで手のひらを検知するということであって、それはまあ微妙な感じ。</p>

<h4 id="つまり">つまり</h4>

<p><strong>残念ながら、手のひら検知がいまいちな件は解決できていない。</strong>なんとかする方法の調査はTo Be Continuedである。<br>
デュアルブートしているWindowsの側ではできているっぽいので、Arch Linux側でも出来ないことないと信じて。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arch LinuxとWindows8.1をデュアルブートにしたときの備忘録]]></title>
    <link href="http://pankona.github.io/blog/2014/05/14/arch-windows-multiboot-tips/"/>
    <updated>2014-05-14T17:59:10+09:00</updated>
    <id>http://pankona.github.io/blog/2014/05/14/arch-windows-multiboot-tips</id>
    <content type="html"><![CDATA[<h2 id="このポストは">このポストは</h2>

<p>Windows8.1に対してWindows Updateしたところ、何だかわからないがデュアルブートしなくなって焦ったため、<br>
直し方というか、そもそもどうやってデュアルブートにしているかをメモしておくための記事。</p>

<h3 id="件のpcについて">件のPCについて</h3>

<p>以下のようなPCと、その中身の構成にしている。</p>

<p>-- PC本体：Vaio Pro 13<br>
-- OS：Arch LinuxとWindows8.1のデュアルブート</p>

<h3 id="デュアルブートのためにしたこと---まずは普通にarch-linuxをインストール">デュアルブートのためにしたこと - まずは普通にArch Linuxをインストール</h3>

<ul>
<li>Arch Linux起動のためのUSBメモリを作成。ここはWindowsを使う。</li>
</ul>

<p><a href="https://wiki.archlinux.org/index.php/USB_Installation_Media_(%E6%97%A5%E6%9C%AC%E8%AA%9E)">USB Installation Media（日本語） - Arch LinuxのWiki</a> なんかが参考になる。</p>

<ul>
<li>Windowsを使ってLinux向けのパーティションを切る。</li>
</ul>

<p>「管理」を使ってやる。<a href="http://windows.microsoft.com/ja-jp/windows/create-boot-partition#1TC=windows-7">ブート パーティンションを作成する - Microsoftのページ</a>等が参考になる。<br>
とにかく何か領域が空いていればいい。うちの構成では180GB程度確保した。<br>
少なくとも30GBくらいいるかな？</p>

<ul>
<li>Arch Linux起動用のUSBを挿した状態でPCを起動し、USBからのブートを行う。</li>
</ul>

<p>あとは↑で作ったパーティションにArch Linuxをインストールしていく。詳しくはやはりArch LinuxのWiki参照。<br>
-- パーティションのフォーマット。割り当て可能領域はすべて割り当て。EFIパーティションにする必要はない。普通ので。<br>
-- /mnt にフォーマットしたパーティションをマウント。<code>mount /dev/sda5 /mnt</code> ← うちの環境の場合。<br>
-- chrootする。<code>arch-chroot /mnt</code> で。 <br>
-- Arch Linuxのインストール。 <code>pacman -S base base-devel</code> とかやる。<br>
-- genfstab とかそういったことをこまごま行う。<br>
-- ブートローダのインストール。ブートローダにはgummibootを採用した。</p>
<div class="highlight"><pre><code class="text">mount /dev/sda2 /boot/EFI
cd /boot/EFI
gummiboot install
</code></pre>
</div>

<p>ここまでで勝手にデュアルブートしてくれたら嬉しかったが、そうはいかなかった（本来はこれだけでOKらしい）。<br>
Vaioのせいなのか、Windowsのせいなのか。。</p>

<h3 id="デュアルブートのためにしたこと---無理やりgummibootを使わせる">デュアルブートのためにしたこと - 無理やりgummibootを使わせる</h3>

<p>上記までで何が起きるかというと、、、<br>
どうやら、せっかくgummibootで設定したブートの設定がPC起動時になかったことにされてしまう模様。<br>
つまりWindowsが問答無用で起動される状態に戻ってしまう。VaioのせいなのかWindowsのせいなのか。。。</p>

<p>この点をちゃんと解決するのは諦めました。<br>
諦めて、Windowsの起動に使われるファイルをgummibootのものと置き換えることでデュアルブートを実現。。<br>
一応、やれればいいや、ということで。</p>

<ul>
<li>先ほどのUSBからArch Linuxを起動し、無理やりgummibootを使わせるようにしにいく</li>
</ul>

<p>-- まず、EFIのパーティションをマウントする。</p>
<div class="highlight"><pre><code class="text">mount /dev/sda2 /mnt/boot/EFI
</code></pre>
</div>

<p>-- Windows起動用のファイルとgummiboot起動用のファイルを置き換える。</p>

<p>--- Windows起動用のファイル ... /boot/EFI/Microsoft/boot/bootmgrfw.efi<br>
--- gummiboot起動用のファイル ... /boot/EFI/gummiboot/gummibootx64.efi</p>

<p>上記のWindows起動用のファイルを、gummiboot起動用のファイルで上書きしてやると、、、<br>
次回のPC起動時には、OS選択の画面が表示されるはず。上書きする前にバックアップしてあげてね。。。</p>

<h3 id="windowsアップデートのときに、bootmgrfw.efiが更新されちゃうことがあるっぽい">Windowsアップデートのときに、bootmgrfw.efiが更新されちゃうことがあるっぽい</h3>

<p>だのでWindowsアップデートでデュアルブートができなくなったりするんだろう。<br>
デュアルブートできなくなったら、いちいちgummibootx64.efiをWindows起動用のファイルに上書きしてやる必要がある。</p>

<h2 id="これでwindowsアップデートも怖くない！">これでWindowsアップデートも怖くない！</h2>
]]></content>
  </entry>
  
</feed>
