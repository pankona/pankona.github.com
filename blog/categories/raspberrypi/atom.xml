<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RaspberryPi | make clean; make]]></title>
  <link href="http://pankona.github.io/blog/categories/raspberrypi/atom.xml" rel="self"/>
  <link href="http://pankona.github.io/"/>
  <updated>2014-07-23T22:09:48+09:00</updated>
  <id>http://pankona.github.io/</id>
  <author>
    <name><![CDATA[pankona]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PiTFTのタッチパネルを動作させる]]></title>
    <link href="http://pankona.github.io/blog/2014/07/23/raspi-touch-panel/"/>
    <updated>2014-07-23T21:54:58+09:00</updated>
    <id>http://pankona.github.io/blog/2014/07/23/raspi-touch-panel</id>
    <content type="html"><![CDATA[<p>前回に引き続き、PiTFTの話題。</p>

<p>前回でPiTFTにコンソール画面だったりXの画面だったりを出力させるところまでいった。<br>
タッチパネルの設定がまだだったので、手順を簡単に記しておく。</p>

<p>例によって、Raspberry PiにはArch Linuxが載っている前提。</p>

<h3 id="タッチパネルのドライバーをロードする">タッチパネルのドライバーをロードする</h3>

<p>前回、FBTFTがビルトインされているカーネルを以下のコマンドでインストールした。</p>

<p><code>$ sudo -E REPO_URI=https://github.com/notro/rpi-firmware BRANCH=builtin rpi-update</code></p>

<p>これが正しく入っていれば、タッチパネルのドライバもカーネルに含まれているはず。<br>
ただし、画面に何かを表示させる時と異なり、手動でドライバをロードする必要がある。</p>

<p>以下のコマンドで、タッチパネルのドライバをロードする。</p>

<p>@@@@ 忘れたのであとで追記する @@@@</p>

<p>基本的にはこれだけで動作すると思われる。<br>
例によって<a href="https://github.com/notro/fbtft/wiki">notroさんのところのWiki</a>に載っている内容だが、<br>
notroさんのところは充実しすぎて逆に迷う気がするので、備忘録的に残しておくことにする。。</p>

<h3 id="動いているか確かめる方法">動いているか確かめる方法</h3>

<p>evtestを用いて確かめられる。<br>
evtestを起動したのちにタッチパネルをぐりぐり触ってみると、<br>
タッチイベントの詳細がコンソールに出力される。</p>

<p>また、正常にドライバがロードされると、<code>/dev/input/touchpanel</code>なるファイルが現れるはずである。<br>
ちなみにこれはeventXへのシンボリックリンクになっている。<br>
このファイルの有無でもドライバのロードが正しく行われたか判断できると思われる。</p>

<h3 id="要追記事項">要追記事項</h3>

<ul>
<li>ドライバロードのコマンドをちゃんと確認する。</li>
<li>キャリブレーション（回転した画面への対応）の方法。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PiTFTをArch Linux on Raspberry Piで動かすのに苦戦]]></title>
    <link href="http://pankona.github.io/blog/2014/07/17/pitft-on-arch-linux/"/>
    <updated>2014-07-17T21:11:11+09:00</updated>
    <id>http://pankona.github.io/blog/2014/07/17/pitft-on-arch-linux</id>
    <content type="html"><![CDATA[<p><strong>2014/07/23/Wed 追記</strong></p>

<p>以下のポストに誤りがあることがわかったので、訂正。<br>
誤っている部分には打ち消し線を入れておく。</p>

<hr>

<p><a href="http://www.adafruit.com/products/1601">PiTFT</a>を購入。<br>
さっそくRaspberry Piで動かそうとしてみたところ、これがなかなかうまくいかず。<br>
3日程粘ってようやく動いた。やり方を記載しておく。</p>

<p>Raspberry Piには、Arch Linuxが載っている前提です。</p>

<h3 id="参考になるページ">参考になるページ</h3>

<p><a href="https://github.com/notro/fbtft/wiki">notroさんのfbtftに関するWiki</a>。本当に感謝。Great。<br>
ただ、ここに書いてある手順を踏んだだけではうまく動かなかった。<br>
以下、顛末と動かすまでの手順。</p>

<h4 id="rpi-updateが使える状態にする">rpi-updateが使える状態にする</h4>

<p>以下、Raspberry Pi上でのコマンド入力。<br>
以下のコマンドでrpi-updateを取得＆実行可能権限付与。</p>

<p><code>$ wget https://raw.github.com/Hexxeh/rpi-update/master/rpi-update</code><br>
<code>$ chmod +x ./rpi-update</code></p>

<p>rpi-updateは適当な場所に移しておく。パスが通っているところに置いておくと便利。<br>
以下、rpi-updateがある場所にパスが通っている前提で記載。</p>

<h3 id="rpi-updateを使ってkernelをアップデート">rpi-updateを使ってKernelをアップデート</h3>

<p>FBTFTドライバがビルトインされているとされるバージョンにしてみる。</p>

<p><code>$ sudo -E REPO_URI=https://github.com/notro/rpi-firmware BRANCH=builtin rpi-update</code></p>

<p>なんやかや起こったあと、リブート。</p>

<p><code>$ sudo reboot</code></p>

<p>これでFBTFTドライバが準備オッケーになっているはず、なのだが…？</p>

<h3 id="fbtft_deviceがない"><del>fbtft_deviceがない</del></h3>

<p><del>fbtft_deviceを有効にするために、modprobeしてみる。</del></p>

<p><code>$ sudo modprobe fbtft_device name=adafruit22</code></p>

<p><del>すると帰ってきた答えは、</del></p>

<p><code>FATAL: Module fbtft_device not found.</code></p>

<p><del>とのこと。実際に探してみたところ、fbtft_device.koというモジュールは存在していない様子。</del></p>

<hr>

<p><strong>2014/07/23/Wed 訂正</strong></p>

<p>結論から言うと上記の挙動であっていた。<br>
<code>BRANCH=builtin</code>を選択した場合はfbtft_deviceがloadableなモジュールとして現れない、<br>
つまり modprobe で見つからないと言われるのは正しかった。</p>

<p>上記の状態で、あとは /boot/cmdline.txt に然るべき内容を追記するだけでOK。<br>
その後PiTFTを接続し、Raspberry Piを再起動すれば画面に何か映るはず。</p>

<p>よって以下の手順はすべて無駄であるが、<br>
以下の手順が誤りであることを示すために残しておく。。</p>

<p>以下、無駄な手順メモ。全く不要。</p>

<hr>

<h3 id="いろいろやってfbtft_deviceを用意する"><del>いろいろやってfbtft_deviceを用意する</del></h3>

<p><del>fbtft_deviceを求めて色々さまよったところ、上述のKernelアップデートの際に、</del></p>

<p><code>sudo REPO_URI=https://github.com/notro/rpi-firmware rpi-update</code></p>

<p><del>とビルトインではなく、loadable moduleとしてfbtft_deviceが現れるやつをチョイスしてみたところ、</del><br>
<code>sudo modprobe fbtft_device name=adafruit22</code>がnot foundではなく、別のエラーになった。<br>
<del>探してみたところ、実際にモジュールは存在した。ただし正常にmodprobeできていない。</del></p>

<p><del>FBTFTのモジュールは、</del><br>
<code>/lib/modules/$(uname -r)/kernel/video/fbtft</code><br>
<del>に置かれている。これをどこか別の場所にコピーしておく。後々使う。</del></p>

<h3 id="rpi-updateを使ってfbtftビルトインバージョンに戻す"><del>rpi-updateを使ってFBTFTビルトインバージョンに戻す</del></h3>

<p><del>上で一回やってるやつをやって、FBTFTビルトインバージョンのKernelに戻す。</del></p>

<p><code>$ sudo -E REPO_URI=https://github.com/notro/rpi-firmware BRANCH=builtin rpi-update</code><br>
<code>$ sudo reboot</code></p>

<h3 id="戻したのち、コピーしておいたfbtftを所定の位置に戻す"><del>戻したのち、コピーしておいたfbtftを所定の位置に戻す</del></h3>

<p><code>/lib/modules/$(uname -r)/kernel/video/fbtft</code>~~の位置に戻す。~~</p>

<h3 id="depmodする。"><del>depmodする。</del></h3>

<p><code>sudo depmod -a</code></p>

<h3 id="fbtft_deviceをmodprobeする"><del>fbtft_deviceをmodprobeする</del></h3>

<p><del>not foundとは言われなくなり、ちゃんとロードされる。はず。</del></p>

<h3 id="あとはnotroさんのところの手順に従う">あとはnotroさんのところの手順に従う</h3>

<p>/boot/cmdline.txtであるとか、もろもろ変更する。<br>
PiTFTはきっと動き出す。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RaspberryPiで動画を配信しながら写真も撮る]]></title>
    <link href="http://pankona.github.io/blog/2014/06/10/raspi-photo-during-streaming/"/>
    <updated>2014-06-10T21:49:47+09:00</updated>
    <id>http://pankona.github.io/blog/2014/06/10/raspi-photo-during-streaming</id>
    <content type="html"><![CDATA[<p>Raspberry Pi＋カメラモジュールを使って、<br>
- 映像をWebページで配信しつつ。<br>
- いま写してる絵を保存する（写真を撮るみたいな）。写真を撮るボタンもWebページに備える。<br>
- 撮った写真はRaspberry Piにとりあえず保存しておいて、Webページ越しに確認できる。<br>
というのをやってみた。<br>
例によっていくつか躓いた点があるので、備忘録的に記しておく。</p>

<h3 id="raspistillでの静止画撮影とmjpg-streamerでの動画配信は同時に行えない？">raspistillでの静止画撮影とmjpg-streamerでの動画配信は同時に行えない？</h3>

<p>どうやらそのようである。最初は、<br>
「Webページ上にボタンを用意し、押されたら <code>raspistill</code> コマンドを発行する。」というやり方でやろうと思ったので当てが外れた感じ。<br>
mjpg-streamerで動画を配信する状態になっている状態でraspistillコマンドを実行すると、エラーが吐かれてしまってうまくいかない。<br>
mjpg-streamerにカメラデバイスを専有されてしまっているとか、そういう雰囲気でうまくいかないんだろうと予想。</p>

<h3 id="mjpg-streamerのsnapshot機能を使う">mjpg-streamerのsnapshot機能を使う</h3>

<p>ではどうするかと言うと、mjpg-streamerには静止画を撮影する機能があるので、これを使ってみた。<br>
<a href="https://code.google.com/p/mjpg-streamer/">mjpg-streamerのプロジェクトのページ</a>に少しサンプルがあって、例えば、mjpg-streamerを動作させている状態でもって、<br>
<code>http://[Raspberry PiのIPアドレス]:8080/?action=stream</code> というURLにアクセスすれば動画配信になり、<br>
<code>http://[Raspberry PiのIPアドレス]:8080/?action=snapshot</code> というURLにアクセスすれば、静止画の撮影になる。<br>
これらは、同時に行うことができる。つまり、これをうまく使えば動画を配信しながら静止画の撮影ができるのでは、と。</p>

<h3 id="wgetで画像を保存する">wgetで画像を保存する</h3>

<p>Webページ上にボタンを用意しておくところまでは同じで、ボタンが押されたら <code>raspistill</code> の代わりに、<code>wget</code> を発行する。<br>
例） <code>wget -O /tmp/picture.jpg http://[Raspberry PiのIPアドレス]:8080/?action=snapshot</code><br>
上記の例では、/tmp/picture.jpgという名前でmjpg-streamerが出力している動画のスナップショットが保存される。<br>
なので一応、動画配信しながら写真を撮る、という目的は達成できた。</p>

<p>できた、が、、、<br>
動画配信中の画像をそのまま静止画にするだけなので、例えば静止画の画質を動画のものより良くする、とか、画像サイズを変更する、アス比を変更する、とかできない。<br>
あくまで動画を一枚切り取っただけ、という感じ。まあ及第点か。。</p>

<h3 id="撮った画像を確認するためにrailsアプリを作った">撮った画像を確認するためにRailsアプリを作った</h3>

<p>Raspberry PiでRailsなんてどうなのか。でもちょっと作ってみた。<br>
目下作り途中だが。とりあえず動いてるのを見るのは楽しい。<br>
<a href="https://github.com/pankona/raspi_camera_server">https://github.com/pankona/raspi_camera_server</a></p>

<ul>
<li>あらかじめmjpg-streamerを起動した状態で、上記Railsアプリを動かす</li>
<li>Railsアプリに何かからアクセスすると、動画が配信されている状態を確認できる</li>
<li>動画をクリックすると、スナップショットが保存される。</li>
<li>保存されたスナップショットは、動画下部に小さく表示される。</li>
</ul>

<p>みたいなもの。テスト書いたりして改善していこう。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry PiでRailsを動かしてみたときのこと]]></title>
    <link href="http://pankona.github.io/blog/2014/05/29/rails-on-raspi/"/>
    <updated>2014-05-29T21:02:35+09:00</updated>
    <id>http://pankona.github.io/blog/2014/05/29/rails-on-raspi</id>
    <content type="html"><![CDATA[<p>Raspberry PiにRailsを入れたときのこと。<br>
あまりすんなりとはいかなかったので、つまづいたところなんかをメモ。<br>
（ちなみにRaspberry Piで動いているOSはArch Linuxです。）</p>

<h2 id="第一の関門-railsのインストール">第一の関門 Railsのインストール</h2>

<p>Raspberry Piにsshで接続し、<code>gem install rails</code> とやるだけでRailsのインストールが始まる。<br>
簡単、、、なのだがこれがなかなか終わらない。しかしこれはただ単純に待てばいいので難しいことは何もない。<br>
終わるまで3時間程度。</p>

<p>sshで接続してる場合、ほっとくとタイムアウトしてしまうと思われる。<br>
その場合は、screen というので対策できる。nohup というのもある。<br>
とにかく長時間放置でタイムアウトしちゃってもいい（ログアウトしちゃってもいい）対策は必要。</p>

<h2 id="第二の関門-bundle-install">第二の関門 bundle install</h2>

<p>Railsアプリを動かす前準備で <code>bundle install</code> 。やると思います。<br>
これがまた死ぬほど時間かかる上に、インストール中に、</p>

<p>killed</p>

<p>とだけ出て終了しちゃう。当然だが bundle install は終わってない。<br>
こっちのが問題だった。</p>

<h3 id="killed-されちゃうのはメモリ不足のため">killed されちゃうのはメモリ不足のため</h3>

<p>bundle install で Killed になっちゃうのは、メモリ不足のための模様。<br>
これは、スワップ領域を設定してあげることで回避できた。<br>
スワップ領域設定の方法については、例によってArch LinuxのWikiを参照した。<br>
何でも載ってるね！ちなみ参照したページは<a href="https://wiki.archlinux.org/index.php/Swap_(%E6%97%A5%E6%9C%AC%E8%AA%9E)">これ - Swap （日本語） - ArchWiki</a>。</p>

<h3 id="killed-されなくなったけど、、、超時間かかる">killed されなくなったけど、、、超時間かかる</h3>

<p>killed されなくなったのはいいけど、Railsのインストールのときと同じく、やたら時間がかかる。。。<br>
9000秒くらいかかったので、実に3時間弱くらい。</p>

<p>なんで時間かかるかというと、まず、 <strong>therubyracer</strong> をインストールしようとしてるのが原因。<br>
これ自体はいれたかったのでいいんだけど、どうやらこいつを入れるのに伴って、 <strong>libv8</strong> というのが入る模様。<br>
そんでこれがどうやら <strong>ソースとってきてビルドしている</strong> ようなのである。Raspberry Piになんてことさせるんや。。。<br>
最近の割とパワーのあるPCなら10分程度で終わるらしいのだが。</p>

<h2 id="まとめると">まとめると</h2>

<p>RailsをRaspberry Piにインストールするためには、</p>

<ul>
<li>スワップ領域を拡大する（bundle install 中に killed されちゃうならば）</li>
<li>あとはひたすら待つ。トータルで6時間くらい待つ。</li>
</ul>

<p>ちなみにRailsの起動がまたすっとろい。webrickじゃなくてthinにするとちょっとだけ早くなる気がする、とか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi + カメラモジュール + Webで配信]]></title>
    <link href="http://pankona.github.io/blog/2014/05/05/raspi-livestream-web/"/>
    <updated>2014-05-05T23:38:52+09:00</updated>
    <id>http://pankona.github.io/blog/2014/05/05/raspi-livestream-web</id>
    <content type="html"><![CDATA[<p>Raspberry Piにカメラモジュールを接続し、映像をWebで配信させてみた。<br>
いろいろ悩んだ点もあったので、やり方の結論をメモしておく。<br>
ちなみに、Raspberry PiにはArch Linux (ARM版) を載せている。</p>

<h2 id="良さそうな例">良さそうな例</h2>

<p>参考にしたウェブサイトは↓。結論からするとここだけでOKだった。<br>
<a href="https://github.com/jacksonliam/mjpg-streamer">https://github.com/jacksonliam/mjpg-streamer</a></p>

<h2 id="上記のリポジトリの情報を元にやったこと">上記のリポジトリの情報を元にやったこと</h2>

<h3 id="mjpg-streamerのインストール。">mjpg-streamerのインストール。</h3>

<p>上記のリポジトリからソースコードをもってきてビルド。ビルド方法も上記のリポジトリのREADMEに記載されている。<br>
pacmanであったりyaourtで取得できるmjpg-streamerのパッケージは使わない。それらはinput_raspicam.soを作ってくれないため。</p>

<h3 id="超簡単にhtmlを書く。">超簡単にhtmlを書く。</h3>

<p>下記のような。とりあえずサンプルなので、簡単に。。<br>
書いたHTMLは、任意の場所におく。ここではひとまず、<code>~/www/index.html</code>として置いたとする。</p>
<div class="highlight"><pre><code class="html"><span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Raspberry Pi<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&quot;http://pankona.github.io/?action=stream&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre>
</div>

<h3 id="配信するコマンドを実行する。">配信するコマンドを実行する。</h3>

<p>このコマンドも件のリポジトリに記載されているが、一応。<br>
ライブラリ（.so）へのパスが通ってなかったら、LD_LIBRARY_PATHを設定してライブラリへのパスを通すか、もしくはライブラリをフルパスで指定する。</p>

<p><code>mjpg_streamer -o &quot;output_http.so -w ./www&quot; -i &quot;input_raspicam.so -x 1280 -y 720 -fps 15 -ex night&quot;</code></p>

<p>こんな感じに入力してやると、カメラが動き出して動画配信が始まる。<br>
別のPC等からブラウザで、</p>

<p><code>http://[Raspberry PiのIPアドレス]:8080/</code></p>

<p>にアクセスしてあげると、カメラが写してる画像が配信されているのが確認できると思われる。</p>
]]></content>
  </entry>
  
</feed>
